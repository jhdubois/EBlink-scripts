//! NXP lpc
// Adapted from stmicro scripts by J.DuBois
// at Thermalogic Corporation (jer@thlogic.com)
//
/////////////////////////////////////////////////////
//
//     This is a virtual device for NXP LPC cortex's
//     The real device type is checked by reading
//     the device ID and include the corresponding
//     device script's
//
//     The script tries to detect the right memory sizes
//     however, if this is not correct you can set the sizes
//     in kilobytes on the command line as:
//
//         -D FLASH_SIZE=xxx  and -D RAM_SIZE=xxxx  (check also device scripts)
//

intrfApi <- InterfAPI()  // Global so that all included script files also have access
targetApi<- TargetAPI()  // Global interface to the target class
deviceId <- 0            // Global deviceId
deviceType <- 0			 // Global deviceType

// Used by script to denote a not found devcie
const ERROR_NOT_FOUND -100

const BKPT	   0xBEAABEAA	// Breakpoint instruction
const IAP_SIG_176X 0xBA72F700	// Signature to identify that IAP entry point exists on 176x devices
const IAP_SIG	   0xF7FEB510	// Signature to identify that IAP entry point exists on 1100XL devices
const IAP_ADDR     0x1FFF1FF1	// IAP entry point
const IAP_ADDR_800 0x0F001FF1	// IAP entry point for LPC800 series
const RETURN_ADDR  0x10000010
const PARAM_ADDR   0x10000030
const RESULT_ADDR  0x100000D0

NXP_KINETIS_DEVICEID <- [			// Kinetis Device ID register locations
	0x40048024,
	0x40075024,
]

NXP_LPC_DEVICEID <- [				// LPC Device ID register locations
	0x400483F8,
	0x400483F4,
]

const IAP_READPARTID 54

const NXP_LPC 0
const NXP_KINETIS 1
/////////////////////////////////////////////////////
//
//  EBlink called Entry point
//

function main()
{

    try {
        findDevice()
    }
    catch(e)
    {
        if( e == ERROR_NOT_FOUND)
            if(deviceId) {
                printf("\n\nPlease report this ID so that we can add it.\n")
                errorf("Error unsupported NXP LPC ID: 0x%X\n", deviceId)
            }
            else
                errorf("ERROR: No valid NXP LPC device ID found\n")
        else
            errorf("Error:\tCan't access target device!\n\tIf reset is disabled (\"dr\" option), try with reset.")
        return ERROR_NOTIFIED  // We have already thrown an error so use -1 (otherwise < -1)
    }
    return ERROR_OK
}

/////////////////////////////////////////////////////
//
//
//
function findDevice()
{
    // Check if the right script API is supported
    if( VERSION < 4.7) {
       errorf("Error:\n\nIncompatiable EBlink version %.1f\n\tPlease update\n", VERSION)
       throw ERROR_NOTIFIED
    }

    // Read the Kinetis Deivce ID
    deviceId = readKinetisDeviceID()
    
    // If zero, read the LPC Device ID
    if (deviceId == 0) {
        deviceId = readLPCDeviceID()

		if(deviceId == 0) throw ERROR_NOT_FOUND

		// We have valid device LPC ID which will be used to load the right scripts
		set_target(NXP_LPC)
    }
    
    // We have valid device Kinetis ID which will be used to load the right scripts
    else set_target(NXP_KINETIS)
}

/////////////////////////////////////////////////////
//
//
//
function readKinetisDeviceID()
{

  // Try to read a DEVICE_ID register
  
  for (local i=0;i<NXP_KINETIS_DEVICEID.len();i++) {
   	_n_throw(intrfApi.readMem32(NXP_KINETIS_DEVICEID[i]))
	if (intrfApi.value32 > 0x1002 || (intrfApi.value32 < 0 || intrfApi.value32 > 0x90000000)) return(intrfApi.value32)
  }
  
  // No Kinetis device detected
  return(0)
}

/////////////////////////////////////////////////////
//
//
//
function readLPCDeviceID()
{
   _n_throw( targetApi.halt() )

   // Try to read a DEVICE_ID register
	
   for (local i=0;i<NXP_LPC_DEVICEID.len();i++) {
   	_n_throw(intrfApi.readMem32(NXP_LPC_DEVICEID[i]))
	if (intrfApi.value32 >= 0x00007000 && intrfApi.value32 <= 0x46000000) {
		return(intrfApi.value32)
	}
   }

   // Otherwise, check to make sure we're dealing with an NXP LPC device by
   // looking for the IAP signature at the IAP routine memory locations

   _n_throw(intrfApi.readMem32(IAP_ADDR))

   if (intrfApi.value32 != IAP_SIG && intrfApi.value32 != IAP_SIG_176X) {
	 _n_throw(intrfApi.readMem32(IAP_ADDR_800))
	 if (intrfApi.value32 != IAP_SIG) return(0)
   }

   // Write params to data ram space
   _n_throw( intrfApi.writeMem32(PARAM_ADDR, IAP_READPARTID) )
   _n_throw( intrfApi.writeMem32(RESULT_ADDR+4,0) )

   // Write the param and result addresses into R0/R1
   _n_throw( targetApi.writeReg("R0", PARAM_ADDR) )
   _n_throw( targetApi.writeReg("R1", RESULT_ADDR) )

   // Write the return address to the LR register, and set the BKPT instruction at
   // the return address
   _n_throw( targetApi.writeReg("LR", RETURN_ADDR+1) )
   _n_throw( intrfApi.writeMem32(RETURN_ADDR, BKPT) )

   // Execute the IAP command (If there's nothing at the standard IAP entry address,
   // try the LPC800 entry address)
   _n_throw(intrfApi.readMem32(IAP_ADDR_800))

   if (intrfApi.value32 == IAP_SIG)
	_n_throw( targetApi.execute(IAP_ADDR_800, true) )
   else
	_n_throw( targetApi.execute(IAP_ADDR, true) )

   // Read result
   _n_throw( intrfApi.readMem32(RESULT_ADDR+4) )

// Return result

   return(intrfApi.value32)

}

/////////////////////////////////////////////////////
//
//
//
function set_target(type)
{
    noticef("NXP device : 0x%X\n", deviceId)

    if (type == NXP_LPC) {
    
    	if (deviceId >= 0x00008021 && deviceId <= 0x00008044)
		require("nxp/lpc800.script")

    	else if ((deviceId >= 0x25001110 && deviceId <= 0x25113737) ||
		     (deviceId >= 0x26011922 && deviceId <= 0x26113F37))
        	require("nxp/lpc1700.script")

    	else
        	require("nxp/lpc1100.script")

	// Call our generic entry point of the device script we just loaded
    	lpc_device()
    }
    else {
    
    	require("nxp/kinetis.script")
	kinetis_device()
    }
}

/////////////////////////////////////////////////////////////////////////////////
//
// Additional commands after reset (optional) called by EBlink
//
// resetType:
//        SYSTEM_RESET
//        CORE_RESET
//        JTAG_RESET
//        USER_RESET
//
function  reset_post(resetType)
{

    // Check if there is an user defined post reset hook, the user
    // can add his own reset strategy with -S <myscript> as last
    // defined script on the cli.
    if (isScriptObject("reset_post_hook"))
        return reset_post_hook(resetType);

    // We don't use this if the reset is a user_script type. In that
    // case, the user is responsible for the initialization.
    //
    if( resetType != USER_RESET )
    {
        // The reset strategies are defined in (lower) part definition scripts
    }

    return ERROR_OK
}

